# 如何理解非阻塞I/O（详解）

node有三大特征：单线程、非阻塞I/O，事件驱动

## 非阻塞I/O
非阻塞 I/O，也叫异步 I/O，显然对应的就是阻塞式 I/O

传统的服务器语言大多是多线程、阻塞式 I/O。这也是 Node 与众不同的地方，对于传统的服务器语言，在与用户建立连接时，每一个连接都是一个线程。 当有十万个用户连接时，服务器上就会有十万个线程。而阻塞式 I/O 是指，当一个线程在执行 I/O 操作时，这个线程会阻塞，等待 I/O 操作完成后继续执行。

>举个例子可以更好理解，比如我们到一个餐馆吃饭，这个餐馆比较高级，服务员是一对一服务（每个用户都是一个线程），从我们坐下开始，服务员就把菜单给你，然后在旁边等你点菜（等待 I/O 操作），当你看完菜单，把要点的菜告诉服务员（ I/O 操作结束后线程继续执行）。在你看菜单的过程中，服务员其实是被闲置的，如果你一直看，他就会一直等，直到你点完（ I/O 操作结束）。这就是阻塞式 I/O。

上面的例子应该可以很好地理解多线程、阻塞式 I/O 。而 node 的特性是单线程、非阻塞时 I/O 。node 最大的优势就是性能强，同样的服务器性能使用 node 可以比传统的服务器语言多容纳一百倍的用户（对于不同的任务有不同的差别， I/O 操作越多，node优势越明显，如果都是 CPU 计算任务，那他俩几乎没有区别（上面的例子中，忽略顾客的看菜单时间）。

> 还是用上面的例子再比喻一下单线程、非阻塞式 I/O 。这应该是个规模比较小的餐馆，或者说老板比较穷，雇不起大量的服务员，因此只能雇佣一个服务员。当有顾客来时，服务员把菜单送过去，顾客开始看菜单（ I/O 操作），这个时候，服务员是被释放了的，他不用等待顾客看菜单，服务员说：“您先看着菜单，点好了叫我”（回调函数）。这个时候这个服务员就可以抽身去服务其他的顾客。用这种模式的话，一个服务员就可以服务多位顾客，而且不需要等待 I/O ，只需要随时监听就行了，顾客点完后会主动叫服务员（执行回调函数）。

单线程、非阻塞式 I/O 的优势就是性能强，一个人服务员就可以解决大量顾客。但是他的缺点也很明显，比如有一桌顾客和服务员又吵架了（线程崩了！），那这些顾客就都完了，因为所有人都在等这一个服务员。也就是说，如果线程崩掉了，那与这个服务器连接的所有用户都会崩溃。

但是，还有一个问题就是，如果有多个顾客都在叫你，该如何响应？肯定要有一定的规则，这就涉及到了 node 的事件驱动。所以说，这三大特点，其实也是一个事，缺任何一个都不行。

参考文档：https://blog.csdn.net/TalonZhang/article/details/88414752